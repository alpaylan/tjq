 //     // since this is a local scope i will use an extension hash map with addition to the outer scope
        //     // why? -> shadowing for func names/defs
        //     // ok recurse parse filter call with a local defs 
        //     // use a new filter to utilize local defs without pushing to global

        //     let mut local_defs = defs.clone();
   
        //     let func_def = parse_filter(
        //         code,
        //         root.child(0)
        //             .expect("function expression should have a function definition"),
        //         &mut local_defs,
        //     );
            
        //     let expr = parse_filter(
        //         code,
        //         root.child(1)
        //             .expect("function expression should have a body"),
        //         &mut local_defs,
        //     );
            
        //     let local_only: HashMap<String, Filter> = local_defs.iter()
        //         .filter(|(k, _)| !defs.contains_key(*k))
        //         .map(|(k, v)| (k.clone(), v.clone()))
        //         .collect();
            
        //     if !local_only.is_empty() {
        //         Filter::FunctionExpression(local_only, Box::new(expr))
        //     } else {
        //         expr
        //     }
        